package server

import (
	"context"

	"github.com/fragments/fragments/internal/backend"
	"github.com/fragments/fragments/internal/filestore"
	"github.com/fragments/fragments/internal/state"
	"github.com/pkg/errors"
)

// Server is the fragments server that accepts resources and keeps them in the
// store.
type Server struct {
	StateStore    backend.KV
	SourceStore   filestore.SourceTarget
	GenerateToken func() string
}

// New creates a new server.
// Upload tokens are generated by server.GenerateToken.
func New(stateStore backend.KV, sourceTarget filestore.SourceTarget) *Server {
	return &Server{
		StateStore:    stateStore,
		SourceStore:   sourceTarget,
		GenerateToken: GenerateToken,
	}
}

// UploadRequest is a request for source code, returned from the server.
type UploadRequest struct {
	// Token is the token to use when confirming the upload.
	Token string
	// URL is where to upload the source code. The source must be uploaded as a
	// tar.gz. After completion the upload should be confirmed.
	URL string
}

// PutFunction creates or updates a function. In case the function already
// exists it is updated. If not, source upload is requested.
func (s *Server) PutFunction(ctx context.Context, input *state.Function) (*UploadRequest, error) {
	// Get existing function
	existing, err := state.GetFunction(ctx, s.StateStore, input.Meta.Name)
	if err != nil {
		return nil, errors.Wrap(err, "could not check existing function")
	}

	if existing == nil || existing.Checksum != input.Checksum {
		// nolint: vetshadow
		res, err := s.requestUpload(ctx, input, existing)
		if err != nil {
			return nil, errors.Wrap(err, "could not request source upload")
		}
		return res, nil
	}

	if err = s.updateFunctionConfiguration(ctx, input); err != nil {
		return nil, errors.Wrap(err, "could not update function configuration")
	}

	return nil, nil
}

// ConfirmUpload is called by the client when the source has been uploaded
func (s *Server) ConfirmUpload(ctx context.Context, token string) error {
	upload, err := state.GetPendingUpload(ctx, s.StateStore, token)
	if err != nil {
		return errors.Wrap(err, "could not get pending upload")
	}

	if upload == nil {
		return errors.New("not found")
	}

	if err := s.SourceStore.Persist(ctx, token); err != nil {
		return errors.Wrap(err, "could not persist source")
	}

	function := upload.Function
	function.SourceFilename = token

	if err := s.updateFunctionConfiguration(ctx, function); err != nil {
		return errors.Wrap(err, "error storing function update")
	}

	if err := state.DeletePendingUpload(ctx, s.StateStore, token); err != nil {
		return errors.Wrap(err, "could not delete pending upload")
	}

	// TODO(akupila): if set; archive upload.PreviousFilename from source store
	return nil
}

// requestUpload creates a url the client can upload source code to. The upload
// request is stored as a PendingUpload in the store so it can be retrieved
// when the client confirms the upload.
func (s *Server) requestUpload(ctx context.Context, input *state.Function, existing *state.Function) (*UploadRequest, error) {
	token := s.GenerateToken()

	url, err := s.SourceStore.NewUploadURL(token)
	if err != nil {
		return nil, errors.New("could not create upload url")
	}

	pendingUpload := &state.PendingUpload{
		Filename: token,
		Function: input,
	}
	if existing != nil {
		pendingUpload.PreviousFilename = existing.SourceFilename
	}

	if err := state.PutPendingUpload(ctx, s.StateStore, token, pendingUpload); err != nil {
		return nil, errors.Wrap(err, "could not store pending upload in backend")
	}

	uploadRequest := &UploadRequest{
		Token: token,
		URL:   url,
	}

	return uploadRequest, nil
}

// updateFunctionConfiguration updates the function's configuration
// (performance specs, environment variables etc) without updating the source
// code.
func (s *Server) updateFunctionConfiguration(ctx context.Context, input *state.Function) error {
	if err := state.PutFunction(ctx, s.StateStore, input); err != nil {
		return errors.Wrap(err, "could not update function configuration")
	}
	return nil
}
